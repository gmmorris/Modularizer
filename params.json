{"name":"Modularizer","tagline":"A component which encapsulates basic modularization using the AMD API but in a self contained package rather than on the global object","body":"Modularizer [![Build Status](https://travis-ci.org/gmmorris/Modularizer.svg)](https://travis-ci.org/gmmorris/Modularizer)\r\n===========\r\n\r\nModularizer was born out of a need for a self contained module packager which could co exist with other package managers.It is a component which encapsulates basic modularization using the standard AMD API, as implemented by RequireJS, but in self contained \"packages\" of modules, rather than one package which resides on the global object.\r\n\r\nTo learn more about the history behind Modularizer please take a look at the following article by the author of the Modularizer library: (https://medium.com/@chekofif).\r\n\r\n# Defining a package\r\n=================\r\nModularizer packages provide the ability to keep your modules a sandboxed environment to exist, without the danger of multiple modules from different sources clashing due to having identical names. Think of them as a namespace, if that helps.\r\n\r\n## Creating a package\r\nCreating a new package couldn't be simpler.\r\nIt is done by creating a new instance of the Modularizer Constructor function, like so:\r\n`\r\nvar myModularizer = new Modularizer();\r\n`\r\n\r\nFrom that moment you have a package, accessible through the _myModularizer_ variable, into which you can define modules and resources.\r\n\r\n## Configuring a package\r\nThe Modularizer has a default configuration which dictates the behaviour of a package, but all of these can be overridden when the package is created.\r\n\r\nThe following is the default config:\r\n`\r\n\r\n  // default config\r\n  Modularizer.config = {\r\n    /**\r\n     *  Should we use console to log messages?\r\n     *  True/False\r\n     *  */\r\n    debug: false,\r\n    /**\r\n     * Cache Buster value to add to all JS scripts added by the loader.\r\n     * To allow maximum flexibility the Cache buster makes no assumptions other than it's location being\r\n     * at the end of the URI.\r\n     * This allows you to make it a parameter, like '?cb=XXX', or any other postfix you wish on the URL.\r\n     * We found it comfortable to use the hash of the file's last Git commit, which promised us a clear cache\r\n     * every time the file was changed, rather than every deployment.\r\n     * */\r\n    cb: false,\r\n    /**\r\n     * A loader function is provided by default, but we do try and detect jQuery first and use that instead if possible.\r\n     * The *loader* function takes either a JS function or a Boolean.\r\n     * True - This value tells Modularizer that it should use a loader, but doesn't tell it which. If the *detectJQuery* config\r\n     *        is set to True, then Modularizer will first try and find jQuery and use that, otherwise it uses an internal file loader.\r\n     * False - Don't try and load missing files. If the required Module isn't defined manually - Modularizer will treat it as a lost\r\n     *        cause and won't try and fetch it on it's own.\r\n     * func() - If a function is provided Modularizer will call it every time a file needs to be fetched for a module's definition.\r\n     *        The syntax for this function is thus: function(filePath, callback)\r\n     *        filePath : The URL of the file that needs to be loaded\r\n     *        callback : A callback for the loader to call when it has fetched the file\r\n     * */\r\n    loader: true,\r\n    detectJQuery: true,\r\n    /**\r\n     *  Should timeouts be narrowed down?\r\n     *  When the modularizer is told to fetch a module definition it injects the resource which, it believes,\r\n     *  contains the module and waits for the module definition to actually take place.\r\n     *  If it waits too long, it triggers a \"timeout\" and throws an exception.\r\n     *  How long it waits is defined by the *timeout* config, which by default, sets a 3 second timeout.\r\n     **/\r\n    timeout: 3000,\r\n    /**\r\n     *  Once a timeout is triggered we can simply throw an error, for the system to deal with, or we can go digging in\r\n     *  the definitions to figure out why the timeout took place.\r\n     *  There are several different reasons which can cause a timeout - a missing dependancy, or a circular reference causing\r\n     *  a deadlock.\r\n     *  Figuring out these reasons can take time and be a complex analysis, so for critical environments, or when a missing module\r\n     *  can be ignored with an appropriate fallback, it may be beneficial to skip this analysis.\r\n     *  Hence, by default, we set this option to false, which means a generic error will be thrown specifying the module's name\r\n     *  but not the missing dependancy or circular reference.\r\n     *  It is recommended to set this configuration to True for Dev environments where it more important to identify the actual\r\n     *  problem.\r\n     *  */\r\n    narrowDownTimeouts: false,\r\n    /***\r\n     * Tag base is the base URL which is used for all resources.\r\n     * When a resource is defined, for example, at 'view/homepage/header.js' and the base configuration is set as 'http://www.gidi.io/static/',\r\n     * the Modularizer loader will specify the whole URL, 'http://www.gidi.io/static/view/homepage/header.js', as the resource's\r\n     * location.\r\n     */\r\n    base: '',\r\n    /**\r\n     * How should requirements which are defined for a module which is unknown be treated? Strictly or Leniently?\r\n     * True - yes, treat strictly and hence throw an error when an unknown module is required.\r\n     * False - no, treat leniently, and hence only throw an error when an actual requirement is made, rather than defined.\r\n     *\r\n     * This is very comfortable for situations where you have dynamically defined modules, which are created at runtime.\r\n     * We found this very useful for injecting Mustache Template definitions which are fetched externally from Modularizer,\r\n     * but required by modules inside of our Modularizer packages.\r\n     * */\r\n    strictRequirment: true,\r\n    /***\r\n     * A string or array of strings with regex matches which will be treated as exceptions for the strictRequirment mode.\r\n     * This means that if these values are matched with a required resource, then they will be treated in the opposite to the specified mode.\r\n     * So if strictRequirment is set to true, the matched modules will be treated leniently and visa versa.\r\n     */\r\n    requirementExceptions: null,\r\n    /***\r\n     * A string or array of strings with regex matches which will be treated as additional exceptions for the strictRequirment mode.\r\n     * This pattern is different than the requirementExceptions only in one aspect - that it applies to the timeout in addition to the requirment.\r\n     * This means that, unlike the requirementExceptions patterns, these modules will be ignored in the timeout as well as having lenient requirment,\r\n     * so when the timeout occurs, their absence will not cause the package to be deemed invalid.\r\n     */\r\n    optionalRequirment: null\r\n  };\r\n`\r\n\r\nWhen you create your package you can override these configurations like so:\r\n`\r\nvar myModularizer = new Modularizer({\r\n      // Very harsh cache buster, every file request will break the cache ;)\r\n      cb : '?cb=' + (new Date).getTime(), \r\n      loader: function(filePath, callback){ ... },\r\n      // Ignore jQuery\r\n      detectJQuery: false\r\n      // 5 seconds\r\n      timeout: 5000  \r\n});\r\n`\r\n\r\n# Defining a resource\r\n=================\r\nA resource is an external file that contains a module or a several modules.\r\nWe can tell our package to expect a specific file to contain a specific module, like so:\r\n`\r\nmyModularizer.register(\"view/homepage/header.js\").defines('View.Header');\r\n`\r\n\r\nWhich means Modularizer will fetch the file _header.js_ when someone requires the module _View.Header_.\r\n\r\nA resource can also contain several modules, such as:\r\n`\r\nmyModularizer.register(\"app/booking.js\")\r\n\t.defines('Model.BookingBasket')\r\n\t.defines('Model.PaymentMethod')\r\n\t.defines('Collection.Products')\r\n\t.defines('Controller.API.Booking')\r\n\t.defines('View.Booking.Header')\r\n\t.defines('View.Booking.CardDetails')\r\n\t.defines('View.Booking.Submission');\r\n`\r\n\r\nThis tells Modularizer that once someone requires any one of the modules in that resource, it  should load the file _app/booking.js_ which will result in all those modules being defined in the package.\r\n\r\n# Defining a module\r\n=================\r\nIn the same way that calling RequireJS's **define()** function defined a module in Require's registry, so will calling the define() method of your package define that module within that package, and will only be visible to other modules within that package.\r\n\r\nDefining a module is the same in Modularizer as in RequireJS, with one caveat - it needs to know what package to define the module into.\r\nThis caveat is why Modularizer is more suited to application architecture, than to generic package management.\r\nThe beauty of RequireJS is that it is a generic, all around, package manager. On the other hand, Modularizer, is designed to allow sand boxed module packages for an application architecture.\r\n\r\nThe definition is done like so:\r\n`\r\nmyModularizer.define('View.HelloMessage',function(){\r\n      return React.createClass({\r\n        render: function() {\r\n          return <div>Hello {this.props.name}</div>;\r\n        }\r\n      });\r\n});\r\n`\r\nThe above example defines a module, identified as _View.HelloMessage_, which is actually a React View.\r\nWhenever the application needs to render this type of view component, it will require the 'View.HelloMessage' module and in return it will receive the React class which can be used to create instances of that module.\r\n\r\nA definition uses the following signature: function(module, dependancies, callback)\r\n1. **module** The name of the module. Must be a String.\r\n2. **dependancies** Optional. The dependancies this module has. An array of strings, each string a module name, which will be fetched before this module definition can be executed.\r\n3. **callback** A function which defines the module. This function is executed only once - the first time the module is required, and it's return value will be passed to anyone requiring the module throughout the system.\r\n\r\n# Requiring a module\r\n=================\r\nWhen you need a module you can simply require it from the Package.\r\nIf the module has already been instantiated, it is simply returned.\r\nOtherwise, if the module has already been defined, it is instantiated and returned to the function.\r\nOtherwise, if the module hasn't even been defined, it's resource is loaded.\r\nIf the module is unknown Modularizer will either throw an error or oush a callback into a queue and wait for the module to be defined (depends on the configuration of the **strictRequirment** config).\r\n\r\n`\r\nmyModularizer.require('App.Init',function(ApplicationInitializer){\r\n     //...\r\n});\r\n`\r\n\r\nThe signature for require() is thus: function(dependancies, callback, context, synchronous)\r\n1. **dependancies** Either String or Array of Strings. The modules to require, which will be passed as arguments to the callback\r\n2. **callback**  Function. The callback which will receive the module instances.\r\n3. **context** Object. The context in which the callback will be executed.\r\n4. **synchronous** Boolean. Should the execution be synchronous or not (by default, not, hence False). If synchronous is required (True) then an error will be thrown if a required module has not yet been defined, even if the Package knows which resources contains the module, it won't try and load the file, as that would require an asynchronous procedure.\r\n\r\n# Special features\r\n=================\r\n1. **Timeout**. Often we will want to track the health of our application and report an error to our Front End analytics when it take our clients too long to load files. To this effect we can set a timeout period which will throw an error when too long a period has passed since a module was required and the definition failed to reach the package. This could happen due to either a resource failing to contain a module's definition, a resource failing to load or a module's definition throwing an error and hence failing to provide an instance for the package.\r\n2. **requirementExceptions**. Sometimes you want to dynamically create a module. An example for this is when you inject Templates into your page (such as Mustache templates) and want to generate modules which will wrap the rendering of these functions.\r\nYou don't want to type up an actual JS module for every template (we created a generic component which auto defined a module for each template fetched onto the page) but you still want to be able to define these template modules as requirements for your actual modules.\r\nIn order to prevent these dynamically defined modules from throwing an error due to them being required but undefined, we can use a configuration called **requirementExceptions** to set a regex which will tell modularizer to avoid throwing an error when these modules are encountered.\r\nFor example, our generic template component, defines these templates with the prefix _Template._ and hence every view module can require it's templates freely and when the template is injected it's module requirments will be fulfilled by modularizer and execution will continue freely.\r\n\r\n`\r\n\r\nvar myModularizer = new Modularizer({\r\n      requirementExceptions: ['^Template\\\\..*']\r\n});\r\n\r\n//...\r\n\r\nmyModularizer.define('View.HelloMessage',['Template.HelloTemplate'], function(Template){\r\n      return React.createClass({\r\n        render: function() {\r\n          return Template;\r\n        }\r\n      });\r\n});\r\n`\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}